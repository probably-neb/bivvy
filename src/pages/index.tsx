import styles from "./table.module.css";

import type { Dispatch, ReactNode, SetStateAction } from "react";
import {
    useCallback,
    useEffect,
    useMemo,
    useReducer,
    useRef,
    useState,
} from "react";
import Head from "next/head";

import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { Skeleton } from "@/components/ui/skeleton";

import type {
    ColumnDef,
    Header,
    HeaderGroup,
    Row,
    RowData,
    SortDirection,
    SortingState,
} from "@tanstack/react-table";
import {
    flexRender,
    getCoreRowModel,
    getSortedRowModel,
    useReactTable,
} from "@tanstack/react-table";
import {
    type Virtualizer,
    notUndefined,
    useVirtualizer,
} from "@tanstack/react-virtual";

import { api } from "@/utils/api";
import type { Person } from "@/server/api/mockData";

const PAGE_SIZE = 20;

declare module "@tanstack/react-table" {
    interface ColumnMeta<TData extends RowData, TValue> {
        noSkeleton?: boolean;
    }
    interface Row<TData extends RowData> {
        original: TData & { _skeleton?: boolean };
    }
}

const columns: ColumnDef<Person>[] = [
    {
        cell: ({ row }) => row.index,
        accessorKey: "#",
        meta: {
            noSkeleton: true,
        },
        enableSorting: false,
    },
    {
        accessorKey: "firstName",
        header: "First Name",
    },
    {
        accessorKey: "lastName",
        header: "Last Name",
    },
    {
        accessorKey: "age",
        header: "Age",
    },
    {
        accessorKey: "organization",
        header: "Organization",
    },
    {
        accessorKey: "group",
        header: "Group",
    },
];

export default function Home() {
    return (
        <>
            <Head>
                <title>Create T3 App</title>
                <meta name="description" content="Generated by create-t3-app" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main className="flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]">
                <DataTable columns={columns} />
            </main>
        </>
    );
}

type Setter<T> = Dispatch<SetStateAction<T>>;

interface DataTableProps<TData, TValue> {
    columns: ColumnDef<TData, TValue>[];
}

export function DataTable<TData, TValue>({
    columns,
}: DataTableProps<TData, TValue>) {
    const rowHeight = 53;
    const fetchingPage = useRef<number | null>(0);
    const [sorting, setSorting] = useState<SortingState>([]);

    const query = api.users.useInfiniteQuery(
        {
            sorting,
        },
        {
            initialCursor: 0,
        },
    );
    const numRows = useMemo(() => {
        console.log("updating numRows")
        const num = query.data?.pages[0]?.meta.totalRowCount ?? 0;
        return num;
    }, [query.data]);

    const pageQueue = usePageQueue([]);

    const [data, fetchedPages] = useMemo(() => {
        console.log("updating data")
        if (!query.data) return [[], []];

        const rows = new Array<TData>(numRows);

        const numPages = pageOfRow(numRows);
        const pages = query.data.pages;
        const fetchedPages = new Array<number>(pages.length);

        for (let i = 0; i < pages.length; i++) {
            const chunk = pages[i]!;
            const page = chunk.meta.page;
            const start = page * PAGE_SIZE;
            const removed = rows.splice(
                start,
                chunk.data.length,
                ...(chunk.data as TData[]),
            );
            console.assert(
                removed.length === PAGE_SIZE,
                "removed.length === PAGE_SIZE",
            );
            fetchedPages[i] = page;
        }
        for (let p = 0; p <= numPages; p++) {
            if (fetchedPages.includes(p)) continue;
            const start = p * PAGE_SIZE;
            const end = start + PAGE_SIZE;
            rows.fill({ _skeleton: true } as unknown as TData, start, end);
        }
        for (const fetchedPage of fetchedPages) {
            void pageQueue.remove(fetchedPage);
        }
        const next = pageQueue.pop();
        if (next) {
            void query.fetchNextPage({ pageParam: next, cancelRefetch: false });
            fetchingPage.current = next;
        } else {
            fetchingPage.current = null;
        }
        return [rows, fetchedPages];
    }, [query.data?.pages]);

    const table = useReactTable({
        data,
        columns,
        state: {
            sorting,
        },
        enableColumnResizing: true,
        manualSorting: true,
        onSortingChange: (sorting) => {
            console.log("sorting changed", {
                sorting,
                pageQueue: pageQueue.data,
                fetchedPages,
            });
            void pageQueue.clear();
            virtualizer.scrollToIndex(0);
            setSorting(sorting);
        },
        columnResizeMode: "onChange",
        getCoreRowModel: getCoreRowModel(),
        getSortedRowModel: getSortedRowModel(),
    });

    const bodyRef = useRef<HTMLDivElement>(null);

    const { rows } = table.getRowModel();

    const virtualizer = useVirtualizer({
        count: rows.length,
        // https://github.com/TanStack/virtual/issues/555#issuecomment-1600642269
        estimateSize: useCallback(() => rowHeight, []),
        getScrollElement: () => bodyRef.current,
        overscan: 10,
    });

    const [pagesToFetch, pagesToFetchChanged] = useChanged(
        () => [virtualizer.scrollOffset],
        () => {
            const range = virtualizer.calculateRange();
            if (!range) {
                // happens somewhat frequently, don't know why
                // returning empty array doesn't cause problems
                return [];
            }
            const visiblePages = new Array<number>();
            // TODO: add overscan but don't prioritize previous rows
            // i.e. start at current start and add leading overscan to end
            for (let i = range.startIndex; i <= range.endIndex; i++) {
                const page = pageOfRow(i);
                if (visiblePages.includes(page)) continue;
                visiblePages.push(page);
            }
            const pagesToFetch = visiblePages.filter(
                (p) =>
                    !fetchedPages.includes(p) &&
                    !pageQueue.has(p) &&
                    p !== fetchingPage.current,
            );
            return pagesToFetch;
        },
    );

    if (pagesToFetchChanged && pagesToFetch.length > 0) {
        console.log("pages to fetch", pagesToFetch);
        const [pageToFetch, ...pagesToQueue] = pagesToFetch as [
            number,
            ...number[],
        ];
        if (pagesToQueue.length > 0) {
            pageQueue.push(pagesToQueue);
        }
        void query.fetchNextPage({
            pageParam: pageToFetch,
            cancelRefetch: true,
        });
    }

    return (
        <div
            ref={bodyRef}
            className="h-[500px] w-[800px] overflow-auto rounded-md border bg-white"
            style={{ overflowAnchor: "none" }}
        >
            <div
                style={{ height: `${virtualizer.getTotalSize()}px` }}
                className="relative"
            >
                <Table>
                    <TableHeader className="sticky top-0 z-[1] bg-white">
                        <HeaderGroups groups={table.getHeaderGroups()} />
                    </TableHeader>
                    <TableBody>
                        <TableRows
                            virtualizer={virtualizer}
                            rows={rows}
                            columnsLen={columns.length}
                        />
                    </TableBody>
                </Table>
            </div>
        </div>
    );
}

interface TableRowsProps<TData> {
    virtualizer: Virtualizer<HTMLDivElement, Element>;
    rows: Row<TData>[];
    columnsLen: number;
}

function TableRows<TData>({
    virtualizer,
    rows,
    columnsLen,
}: TableRowsProps<TData>) {
    if (!rows.length) {
        return (
            <TableRow>
                <TableCell colSpan={columnsLen} className="h-24 text-center">
                    No results.
                </TableCell>
            </TableRow>
        );
    }
    const vitems = virtualizer.getVirtualItems();
    const vrows = new Array(vitems.length);

    // https://github.com/TanStack/virtual/discussions/476
    // https://codesandbox.io/s/virtual-simple-table-cdqqpg?file=/src/App.tsx
    const [before, after] =
        vitems.length > 0
            ? [
                  notUndefined(vitems[0]).start -
                      virtualizer.options.scrollMargin,
                  virtualizer.getTotalSize() - notUndefined(vitems.at(-1)).end,
              ]
            : [0, 0];

    for (let i = 0; i < vitems.length; i++) {
        const vitem = vitems[i]!;
        const row = rows[vitem.index]!;
        vrows[i] = (
            <TableRow
                key={vitem.key}
                data-state={row.getIsSelected() && "selected"}
            >
                <RowCells row={row} />
            </TableRow>
        );
    }
    return (
        <>
            {before > 0 && (
                <tr>
                    <td colSpan={columnsLen} style={{ height: before }} />
                </tr>
            )}
            {vrows}
            {after > 0 && (
                <tr>
                    <td colSpan={columnsLen} style={{ height: after }} />
                </tr>
            )}
        </>
    );
}

interface RowCellsProps<TData> {
    row: Row<TData>;
}

function RowCells<TData>({ row }: RowCellsProps<TData>) {
    const visibleCells = row.getVisibleCells();
    const renderedCells = new Array<ReactNode>(visibleCells.length);

    const isSkeleton = row.original._skeleton;

    for (let i = 0; i < visibleCells.length; i++) {
        const cell = visibleCells[i]!;
        const key = cell.id;
        if (isSkeleton && !cell.column.columnDef.meta?.noSkeleton) {
            renderedCells[i] = (
                <TableCell key={key}>
                    <Skeleton
                        className="w-9/12"
                        style={{
                            height: "1rem",
                        }}
                    />
                </TableCell>
            );
            continue;
        }
        renderedCells[i] = (
            <TableCell key={key}>
                {flexRender(cell.column.columnDef.cell, cell.getContext())}
            </TableCell>
        );
    }
    return renderedCells;
}

function HeaderGroups<TData>({ groups }: { groups: HeaderGroup<TData>[] }) {
    const renderedGroups = new Array<ReactNode>(groups.length);
    for (let g = 0; g < groups.length; g++) {
        const group = groups[g]!;
        const len = group.headers.length;
        const renderedHeaders = new Array<ReactNode>(len);
        for (let h = 0; h < len; h++) {
            const header = group.headers[h]!;
            renderedHeaders[h] = (
                <IndividualHeader key={header.column.id} header={header} />
            );
        }
        renderedGroups[g] = (
            <TableRow key={group.id}>{renderedHeaders}</TableRow>
        );
    }
    return renderedGroups;
}

function IndividualHeader<TData>({
    header,
}: {
    header: Header<TData, unknown>;
}) {
    const setSort = useCallback(
        (newSort: SortDirection | false) => {
            const column = header.column;
            const curSort = column.getIsSorted();
            const unchanged =
                (!curSort && newSort === null) || curSort === newSort;
            if (unchanged) {
                console.warn("uneccessary set sorting");
                return;
            }

            if (newSort === null) {
                console.log("clearing sorting", header.column.columnDef.header);
                column.clearSorting();
                return;
            }
            console.log(
                "setting sorting",
                newSort,
                header.column.columnDef.header,
            );
            const desc = newSort === "desc";
            column.toggleSorting(desc);
        },
        [header],
    );
    return (
        <TableHead
            key={header.id}
            colSpan={header.colSpan}
            style={{
                width: header.getSize(),
                position: "relative",
            }}
        >
            {header.isPlaceholder
                ? null
                : flexRender(
                      header.column.columnDef.header,
                      header.getContext(),
                  )}
            {header.column.getCanSort() ? (
                <HeaderSortIcon setSort={setSort} />
            ) : null}
            <div
                className={`${styles.resizer} ${
                    header.column.getIsResizing() ? styles.isResizing : ""
                }`}
                onMouseDown={header.getResizeHandler()}
                onTouchStart={header.getResizeHandler()}
            ></div>
        </TableHead>
    );
}

function usePageQueue(initial: number[]) {
    const data = useRef<number[]>(initial);
    const push = (_pages: number | number[]) => {
        const pages = Array.isArray(_pages) ? _pages : [_pages];
        if (!pages.length) return;
        let pagesAlreadyNextInQueue = true;
        for (let i = -1; i >= -pages.length; i--) {
            if (data.current.at(i) !== pages.at(i)) {
                pagesAlreadyNextInQueue = false;
                break;
            }
        }
        console.log({ data, pages, alreadyNext: pagesAlreadyNextInQueue });
        if (pagesAlreadyNextInQueue) return;
        data.current = data.current.filter((p) => !pages.includes(p));
        data.current.push(...pages);
        console.log("enqueuing", ...pages);
    };
    const pop = () => data.current.pop();

    const remove = (value: number) => {
        if (!data.current.includes(value)) return false;
        data.current = data.current.filter((x) => x !== value);
        return true;
    };
    const clear = () => {
        data.current = [];
    };

    const peek = () => data.current.at(-1);

    const has = (value: number) => data.current.includes(value);

    return {
        push,
        pop,
        clear,
        peek,
        data: data.current as readonly number[],
        has,
        remove,
    };
}

function pageOfRow(row: number) {
    if (row < PAGE_SIZE) {
        return 0;
    }
    const page = Math.floor(row / PAGE_SIZE);
    return page;
}

type HeaderSort = "none" | "asc" | "desc";

const stateMap = {
    none: {
        next: "asc",
        symbol: "o",
        sort: false,
    },
    asc: {
        next: "desc",
        symbol: "^",
        sort: "asc",
    },
    desc: {
        next: "none",
        symbol: "v",
        sort: "desc",
    },
} as const;

function HeaderSortIcon({
    setSort,
}: {
    setSort: (sort: SortDirection | false) => void;
}) {
    const [state, dispatch] = useReducer((state: HeaderSort) => {
        return stateMap[state].next;
    }, "none");

    const onClick = useCallback(() => {
        dispatch();
        setSort(stateMap[stateMap[state].next].sort);
    }, [state, setSort]);

    return (
        <button className="px-2" onClick={onClick}>
            {stateMap[state].symbol}
        </button>
    );
}

export type NoInfer<T> = [T][T extends any ? 0 : never];

import isEqualDeep from "lodash/isEqual";

// TODO: add changedFlag opt to have depsChanged work with a boolean flag
// i.e. the result of a previous onChanged call
export function useChanged<TDeps extends readonly any[], TResult>(
    getDeps: () => [...TDeps],
    fn: (args: NoInfer<[...TDeps]>, prev: NoInfer<[...TDeps]>) => TResult,
    opts: {
        key?: any;
        debug?: boolean;
        time?: boolean;
    } = {},
): readonly [TResult, boolean] {
    const deps = useRef<any[]>([]);
    const result = useRef<TResult | undefined>();
    let depTime: number;
    if (opts.time) depTime = Date.now();

    const newDeps = getDeps();

    const depsChanged =
        newDeps.length !== deps.current.length ||
        newDeps.some((dep: any, index: number) => deps.current[index] !== dep);

    if (!depsChanged) {
        return [result.current!, false];
    }

    let resultTime: number;
    if (opts.time) resultTime = Date.now();
    const newResult = fn(newDeps, deps as any);
    const resChanged = !isEqualDeep(result.current, newResult);
    if (opts.debug) {
        console.log({
            depsChanged,
            oldDeps: deps.current,
            newDeps,
            resChanged,
            result: result.current,
            newResult,
        });
    }
    if (resChanged) {
        result.current = newResult;
    }
    deps.current = newDeps;

    if (opts.time) {
        const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100;
        const resultEndTime =
            Math.round((Date.now() - resultTime!) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;

        const pad = (str: number | string, num: number) => {
            str = String(str);
            while (str.length < num) {
                str = " " + str;
            }
            return str;
        };

        console.info(
            `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
            `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
                0,
                Math.min(120 - 120 * resultFpsPercentage, 120),
            )}deg 100% 31%);`,
            opts?.key,
        );
    }
    return [result.current!, resChanged] as const;
}
