import Head from "next/head";
import Link from "next/link";

import {
    Table,
    TableBody,
    TableCell,
    TableFooter,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";

import styles from "./table.module.css";

import {
    ColumnDef,
    Row,
    flexRender,
    getCoreRowModel,
    getPaginationRowModel,
    useReactTable,
} from "@tanstack/react-table";
import { useVirtualizer } from "@tanstack/react-virtual";

import { api } from "@/utils/api";
import { Person } from "@/server/api/mockData";
import {
    ComponentPropsWithoutRef,
    MutableRefObject,
    ReactNode,
    useCallback,
    useEffect,
    useMemo,
    useRef,
    useState,
} from "react";

import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";

const PAGE_SIZE = 20;

const columns: ColumnDef<Person>[] = [
    {
        accessorKey: "firstName",
        header: "First Name",
    },
    {
        accessorKey: "lastName",
        header: "Last Name",
    },
    {
        accessorKey: "age",
        header: "Age",
    },
    {
        accessorKey: "organization",
        header: "Organization",
    },
    {
        accessorKey: "group",
        header: "Group",
    },
];

export default function Home() {
    return (
        <>
            <Head>
                <title>Create T3 App</title>
                <meta name="description" content="Generated by create-t3-app" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main className="flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]">
                <DataTable columns={columns} />
            </main>
        </>
    );
}

interface DataTableProps<TData, TValue> {
    columns: ColumnDef<TData, TValue>[];
}

export function DataTable<TData, TValue>({
    columns,
}: DataTableProps<TData, TValue>) {
    const rowHeight = 53;
    const query = api.users.useInfiniteQuery(
        {},
        {
            getNextPageParam: (prev): number | undefined =>
                pageOfRow(prev.meta.totalRowCount) > prev.meta.page
                    ? prev.meta.page + 1
                    : undefined,
            getPreviousPageParam: (prev): number | undefined =>
                prev.meta.page > 0 ? prev.meta.page - 1 : undefined,
            initialCursor: 0,
        },
    );
    const numRows = useMemo(() => {
        return query.data?.pages[0]?.meta.totalRowCount || 0;
    }, [query.data]);

    const data = useMemo(() => {
        if (!query.data) return [];
        const rows: TData[] = new Array(numRows);
        const numPages = pageOfRow(numRows);
        const fetchedPages = new Set();
        const chunks = query.data.pages;
        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i]!;
            const page = chunk.meta.page;
            const start = page * PAGE_SIZE;
            const end = start + chunk.data.length;
            void rows.splice(start, end, ...(chunk.data as TData[]));
            fetchedPages.add(page);
        }
        for (let p = 0; p <= numPages; p++) {
            if (fetchedPages.has(p)) continue;
            const start = p * PAGE_SIZE;
            const end = start + PAGE_SIZE;
            rows.fill({ _skeleton: true } as unknown as TData, start, end);
        }
        return rows;
    }, [query.data]);

    const table = useReactTable({
        data,
        columns,
        enableColumnResizing: true,
        columnResizeMode: "onChange",
        getCoreRowModel: getCoreRowModel(),
    });

    const bodyRef = useRef<HTMLTableSectionElement>(null);

    const { rows } = table.getRowModel();

    const virtualizer = useVirtualizer({
        count: rows.length,
        // https://github.com/TanStack/virtual/issues/555#issuecomment-1600642269
        estimateSize: useCallback(() => rowHeight, []),
        getScrollElement: () => bodyRef.current,
        overscan: 10,
    });

    const RowCell = useCallback(
        ({ key, children }: { key: number | string; children: ReactNode }) => {
            return <TableCell key={key}>{children}</TableCell>;
        },
        [table, rowHeight],
    );

    function renderRow(row: Row<TData>) {
        const visibleCells = row.getVisibleCells();
        const renderedCells = new Array(visibleCells.length);
        // @ts-ignore
        if (row.original._skeleton) {
            for (let i = 0; i < visibleCells.length; i++) {
                const cell = visibleCells[i]!;
                const context = cell.getContext();
                const size = cell.column.getSize();
                const key = cell.id;
                renderedCells[i] = (
                    <RowCell key={key}>
                        <Skeleton
                            className="w-9/12"
                            style={{
                                height: "1rem",
                            }}
                        />
                    </RowCell>
                );
            }
            return renderedCells;
        }
        for (let i = 0; i < visibleCells.length; i++) {
            let cell = visibleCells[i]!;
            const key = cell.id;

            renderedCells[i] = (
                <RowCell key={key}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                </RowCell>
            );
        }
        return renderedCells;
    }

    function renderRows() {
        console.log("rerendering rows");
        if (!rows.length) {
            return (
                <TableRow>
                    <TableCell
                        colSpan={columns.length}
                        className="h-24 text-center"
                    >
                        No results.
                    </TableCell>
                </TableRow>
            );
        }

        const vitems = virtualizer.getVirtualItems();
        const vrows = new Array(vitems.length);

        console.log("vitems", vitems.length, virtualizer.range);
        for (let i = 0; i < vitems.length; i++) {
            const vitem = vitems[i]!;
            const row = rows[vitem.index]!;
            vrows[i] = (
                <TableRow
                    key={vitem.key}
                    data-state={row.getIsSelected() && "selected"}
                    style={{
                        height: `${vitem.size}px`,
                        transform: `translateY(${
                            vitem.start - i * vitem.size
                        }px)`,
                    }}
                >
                    {renderRow(row)}
                </TableRow>
            );
        }
        return vrows;
    }

    return (
        <div
            ref={bodyRef}
            className="h-[500px] w-[800px] overflow-auto rounded-md border bg-white"
        >
            <div
                style={{ height: `${virtualizer.getTotalSize()}px` }}
                className="relative"
            >
                <table className="w-full caption-bottom text-sm">
                    <TableHeader>
                        {table.getHeaderGroups().map((headerGroup) => (
                            <TableRow key={headerGroup.id}>
                                {headerGroup.headers.map((header) => {
                                    return (
                                        <TableHead
                                            key={header.id}
                                            colSpan={header.colSpan}
                                            style={{
                                                width: header.getSize(),
                                                position: "relative",
                                            }}
                                        >
                                            {header.isPlaceholder
                                                ? null
                                                : flexRender(
                                                      header.column.columnDef
                                                          .header,
                                                      header.getContext(),
                                                  )}
                                            <div
                                                className={`${styles.resizer} ${
                                                    header.column.getIsResizing()
                                                        ? styles.isResizing
                                                        : ""
                                                }`}
                                                onMouseDown={header.getResizeHandler()}
                                                onTouchStart={header.getResizeHandler()}
                                            ></div>
                                        </TableHead>
                                    );
                                })}
                            </TableRow>
                        ))}
                    </TableHeader>
                    <TableBody>{renderRows()}</TableBody>
                </table>
            </div>
        </div>
    );
}

function usePageQueue(initial: number[]) {
    const [data, set] = useState<number[]>(initial);

    const push = useCallback(
        (_pages: number | number[]) => {
            const pages = Array.isArray(_pages) ? _pages : [_pages];
            const updated = data.filter((p) => !pages.includes(p));
            updated.push(...pages);
            set(updated);
        },
        [data],
    );

    const pop = useCallback(
        (value: number) => {
            const nextIdx = data.lastIndexOf(value);
            if (nextIdx === -1) return;
            const next = data[nextIdx];
            set(data.filter((_, i) => i !== nextIdx));
            return next;
        },
        [data],
    );

    const clear = useCallback(() => {
        set([]);
    }, [data]);

    const peek = useCallback(() => data.at(-1), [data]);

    return {
        push,
        pop,
        clear,
        peek,
        data,
    };
}

function pageOfRow(row: number) {
    if (row < PAGE_SIZE) {
        return 0;
    }
    const page = Math.floor(row / PAGE_SIZE);

    if (row % PAGE_SIZE === 0) {
        return page - 1;
    }
    return page;
}

function OnVisibleCallbackSkeleton(
    props: ComponentPropsWithoutRef<typeof Skeleton> & {
        onVisible: () => void;
    },
) {
    const ref = useRef(null);
    useVisibleCallback(ref, props.onVisible);
    return (
        <div ref={ref}>
            <Skeleton {...{ ...props, onVisible: undefined }} />
        </div>
    );
}

function useVisibleCallback(
    ref: MutableRefObject<null | HTMLElement>,
    cb: () => void,
) {
    useEffect(() => {
        if (!ref.current) return;
        const observer = new IntersectionObserver(([entry]) => {
            if (entry?.isIntersecting) {
                cb();
                observer.disconnect();
            }
        });

        observer.observe(ref.current);
        return () => {
            observer.disconnect();
        };
    }, [ref]);
}
