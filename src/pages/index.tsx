import styles from "./table.module.css";

import {
    Dispatch,
    SetStateAction,
    useCallback,
    useEffect,
    useMemo,
    useReducer,
    useRef,
    useState,
} from "react";
import Head from "next/head";

import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { Skeleton } from "@/components/ui/skeleton";

import {
    ColumnDef,
    ColumnSort,
    Header,
    HeaderGroup,
    Row,
    SortingState,
    flexRender,
    getCoreRowModel,
    getSortedRowModel,
    useReactTable,
} from "@tanstack/react-table";
import {
    Virtualizer,
    notUndefined,
    useVirtualizer,
} from "@tanstack/react-virtual";

import { api } from "@/utils/api";
import { Person } from "@/server/api/mockData";

const PAGE_SIZE = 20;

const columns: ColumnDef<Person>[] = [
    {
        accessorKey: "firstName",
        header: "First Name",
    },
    {
        accessorKey: "lastName",
        header: "Last Name",
    },
    {
        accessorKey: "age",
        header: "Age",
    },
    {
        accessorKey: "organization",
        header: "Organization",
    },
    {
        accessorKey: "group",
        header: "Group",
    },
];

export default function Home() {
    return (
        <>
            <Head>
                <title>Create T3 App</title>
                <meta name="description" content="Generated by create-t3-app" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main className="flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#2e026d] to-[#15162c]">
                <DataTable columns={columns} />
            </main>
        </>
    );
}

type Setter<T> = Dispatch<SetStateAction<T>>;

interface DataTableProps<TData, TValue> {
    columns: ColumnDef<TData, TValue>[];
}

export function DataTable<TData, TValue>({
    columns,
}: DataTableProps<TData, TValue>) {
    const rowHeight = 53;

    const query = api.users.useInfiniteQuery(
        {},
        {
            initialCursor: 0,
        },
    );
    const numRows = useMemo(() => {
        const num = query.data?.pages[0]?.meta.totalRowCount || 0;
        return num;
    }, [query.data]);

    const data = useMemo(() => {
        if (!query.data) return [];
        const rows = new Array<TData>(numRows);
        const numPages = pageOfRow(numRows);
        const fetchedPages = new Array<number>(numPages);
        const pages = query.data.pages;
        for (let i = 0; i < pages.length; i++) {
            const chunk = pages[i]!;
            const page = chunk.meta.page;
            const start = page * PAGE_SIZE;
            const removed = rows.splice(
                start,
                chunk.data.length,
                ...(chunk.data as TData[]),
            );
            console.assert(
                removed.length === PAGE_SIZE,
                "removed.length === PAGE_SIZE",
            );
            fetchedPages[i] = page;
        }
        for (let p = 0; p <= numPages; p++) {
            if (fetchedPages.includes(p)) continue;
            const start = p * PAGE_SIZE;
            const end = start + PAGE_SIZE;
            rows.fill({ _skeleton: true } as unknown as TData, start, end);
        }
        return rows;
    }, [query.data?.pages]);

    const table = useReactTable({
        data,
        columns,
        enableColumnResizing: true,
        enableSorting: true,
        columnResizeMode: "onChange",
        getCoreRowModel: getCoreRowModel(),
        getSortedRowModel: getSortedRowModel()
    });

    const bodyRef = useRef<HTMLDivElement>(null);

    const { rows } = table.getRowModel();

    const virtualizer = useVirtualizer({
        count: rows.length,
        // https://github.com/TanStack/virtual/issues/555#issuecomment-1600642269
        estimateSize: useCallback(() => rowHeight, []),
        getScrollElement: () => bodyRef.current,
        overscan: 10,
    });

    const pageQueue = usePageQueue([]);

    function onRenderSkeleton(rowIndex: number) {
        const page = pageOfRow(rowIndex);
        console.log("onRenderSkeleton", rowIndex, page);
        pageQueue.push(page);
    }

    useEffect(() => {
        const range = virtualizer.calculateRange();
        const next = pageQueue.peek();
        const withinRange =
            !!range &&
            !!next &&
            next >= range.startIndex &&
            next <= range.endIndex;

        if (withinRange) {
            query.fetchNextPage({ pageParam: next, cancelRefetch: true });
        } else if (next) {
            query.fetchNextPage({ pageParam: next, cancelRefetch: false });
        }
    }, [pageQueue.data]);

    return (
        <div
            ref={bodyRef}
            className="h-[500px] w-[800px] overflow-auto rounded-md border bg-white"
            style={{ overflowAnchor: "none" }}
        >
            <div
                style={{ height: `${virtualizer.getTotalSize()}px` }}
                className="relative"
            >
                <Table>
                    <TableHeader className="sticky top-0 z-[1] bg-white">
                        <HeaderGroups
                            groups={table.getHeaderGroups()}
                            setSorting={table.setSorting}
                        />
                    </TableHeader>
                    <TableBody>
                        <TableRows
                            virtualizer={virtualizer}
                            rows={rows}
                            columnsLen={columns.length}
                            onRenderSkeleton={onRenderSkeleton}
                        />
                    </TableBody>
                </Table>
            </div>
        </div>
    );
}

interface TableRowsProps<TData> {
    virtualizer: Virtualizer<HTMLDivElement, Element>;
    rows: Row<TData>[];
    columnsLen: number;
    onRenderSkeleton: (i: number) => void;
}

function TableRows<TData>({
    virtualizer,
    rows,
    columnsLen,
    onRenderSkeleton,
}: TableRowsProps<TData>) {
    if (!rows.length) {
        return (
            <TableRow>
                <TableCell colSpan={columnsLen} className="h-24 text-center">
                    No results.
                </TableCell>
            </TableRow>
        );
    }
    const vitems = virtualizer.getVirtualItems();
    const vrows = new Array(vitems.length);

    // https://github.com/TanStack/virtual/discussions/476
    // https://codesandbox.io/s/virtual-simple-table-cdqqpg?file=/src/App.tsx
    const [before, after] =
        vitems.length > 0
            ? [
                  notUndefined(vitems[0]).start -
                      virtualizer.options.scrollMargin,
                  virtualizer.getTotalSize() - notUndefined(vitems.at(-1)).end,
              ]
            : [0, 0];

    for (let i = 0; i < vitems.length; i++) {
        const vitem = vitems[i]!;
        const row = rows[vitem.index]!;
        vrows[i] = (
            <TableRow
                key={vitem.key}
                data-state={row.getIsSelected() && "selected"}
            >
                <RowCells row={row} onRenderSkeleton={onRenderSkeleton} />
            </TableRow>
        );
    }
    return (
        <>
            {before > 0 && (
                <tr>
                    <td colSpan={columnsLen} style={{ height: before }} />
                </tr>
            )}
            {vrows}
            {after > 0 && (
                <tr>
                    <td colSpan={columnsLen} style={{ height: after }} />
                </tr>
            )}
        </>
    );
}

function HeaderGroups<TData>({
    groups,
    setSorting,
}: {
    groups: HeaderGroup<TData>[];
    setSorting: Setter<SortingState>;
}) {
    const renderHeader = useCallback((header: Header<TData, unknown>) => {
        function setDesc(desc: boolean | null) {
            const columnId = header.column.id;
            const filterThisCol = (sorting: SortingState) =>
                sorting.filter((sort) => sort.id !== columnId);
            if (desc === null) {
                console.log("clearing sorting", header.column.columnDef.header)
                setSorting(filterThisCol);
                return;
            }
            console.log("setting sorting", desc ? "desc" : "asc" , header.column.columnDef.header)
            setSorting((sorting) => ( [
                ...filterThisCol(sorting),
                { id: columnId, desc },
            ] ));
        }
        return (
            <TableHead
                key={header.id}
                colSpan={header.colSpan}
                style={{
                    width: header.getSize(),
                    position: "relative",
                }}
            >
                {header.isPlaceholder
                    ? null
                    : flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                      )}
                {header.column.getCanSort() ? (
                    <HeaderSortIcon setDesc={setDesc} />
                ) : null}
                <div
                    className={`${styles.resizer} ${
                        header.column.getIsResizing() ? styles.isResizing : ""
                    }`}
                    onMouseDown={header.getResizeHandler()}
                    onTouchStart={header.getResizeHandler()}
                ></div>
            </TableHead>
        );
    }, []);
    const renderedGroups = new Array(groups.length);
    for (let g = 0; g < groups.length; g++) {
        const group = groups[g]!;
        const len = group.headers.length;
        const renderedHeaders = new Array(len);
        for (let h = 0; h < len; h++) {
            const header = group.headers[h]!;
            renderedHeaders[h] = renderHeader(header);
        }
        renderedGroups[g] = (
            <TableRow key={group.id}>{renderedHeaders}</TableRow>
        );
    }
    return renderedGroups;
}
interface RowCellsProps<TData> {
    row: Row<TData>;
    onRenderSkeleton: (i: number) => void;
}
function RowCells<TData>({ row, onRenderSkeleton }: RowCellsProps<TData>) {
    const visibleCells = row.getVisibleCells();
    const renderedCells = new Array(visibleCells.length);

    // @ts-ignore
    const isSkeleton = row.original._skeleton;

    useEffect(() => {
        const isFirstRowOfPage = row.index % PAGE_SIZE === 0;
        const isLastRowOfPage = (row.index + 1) % PAGE_SIZE === 0;
        if (isSkeleton && (isFirstRowOfPage || isLastRowOfPage)) {
            // only notify of skeleton render if it's the first or last row of a page
            onRenderSkeleton(row.index);
        }
    }, [row]);

    if (isSkeleton) {
        for (let i = 0; i < visibleCells.length; i++) {
            const cell = visibleCells[i]!;
            const key = cell.id;
            renderedCells[i] = (
                <TableCell key={key}>
                    <Skeleton
                        className="w-9/12"
                        style={{
                            height: "1rem",
                        }}
                    />
                </TableCell>
            );
        }
        return renderedCells;
    }
    for (let i = 0; i < visibleCells.length; i++) {
        let cell = visibleCells[i]!;
        const key = cell.id;

        renderedCells[i] = (
            <TableCell key={key}>
                {flexRender(cell.column.columnDef.cell, cell.getContext())}
            </TableCell>
        );
    }
    return renderedCells;
}

function usePageQueue(initial: number[]) {
    const [data, set] = useState<number[]>(initial);

    const push = useCallback(
        (_pages: number | number[]) => {
            const pages = Array.isArray(_pages) ? _pages : [_pages];
            set((data) => {
                const updated = data.filter((p) => !pages.includes(p));
                updated.push(...pages);
                console.log("enqueing", ...pages);
                return updated;
            });
        },
        [data],
    );

    const pop = useCallback(
        (value?: number) => {
            if (!value) {
                value = data.at(-1);
                if (!value) return;
            }
            const nextIdx = data.lastIndexOf(value);
            if (nextIdx === -1) return;
            const next = data[nextIdx];
            set((data) => data.filter((_, i) => i !== nextIdx));
            return next;
        },
        [data],
    );

    const clear = useCallback(() => {
        set([]);
    }, [data]);

    const peek = useCallback(() => data.at(-1), [data]);

    const has = useCallback((value: number) => data.includes(value), [data]);

    return {
        push,
        pop,
        clear,
        peek,
        data,
        has,
    };
}

function pageOfRow(row: number) {
    if (row < PAGE_SIZE) {
        return 0;
    }
    const page = Math.floor(row / PAGE_SIZE);
    return page;
}

type HeaderSort = "none" | "asc" | "desc";

function HeaderSortIcon({
    setDesc,
}: {
    setDesc: (sort: boolean | null) => void;
}) {
    const stateMap = useMemo(() => ({
        none: {
            next: "asc",
            symbol: "o",
            desc: null
        },
        asc: {
            next: "desc",
            symbol: "^",
            desc: false
        },
        desc: {
            next: "none",
            symbol: "v",
            desc: true
        }
    } as const), [])
    const [state, dispatch] = useReducer((state: HeaderSort) => {
        return stateMap[state].next
    }, "none");

    let symbol = useMemo(() => stateMap[state].symbol, [state]);
    useEffect(() => {
        setDesc(stateMap[state].desc)
    }, [state])

    return (
        <button className="px-2" onClick={dispatch}>
            {symbol}
        </button>
    );
}
